import pandas as pd
import random
from sentence_transformers import SentenceTransformer, util
import os
import csv

class InterviewSystem:
    def __init__(self):
        # CORRECT path for questions.csv - same as your app.py logic
        BASE_DIR = os.path.dirname(os.path.abspath(__file__))  # backend folder
        PROJECT_ROOT = os.path.dirname(BASE_DIR)  # my-interview-app folder
        PARENT_DIR = os.path.dirname(PROJECT_ROOT)  # parent of my-interview-app
        
        questions_path = os.path.join(PARENT_DIR, "Interview Questions and Grading", "questions.csv")
        print(f"=== INTERVIEW SYSTEM INIT ===")
        print(f"Looking for questions at: {questions_path}")
        print(f"Questions file exists: {os.path.exists(questions_path)}")
        
        self.questions_df = pd.read_csv(questions_path)
        self.model = SentenceTransformer('all-MiniLM-L6-v2')
        print("âœ“ Interview system initialized successfully!")
        
    def get_categories_from_resume(self):
        """Read categories from categories_output.csv generated by resume scanner"""
        # CORRECT path - same as your app.py
        BASE_DIR = os.path.dirname(os.path.abspath(__file__))  # backend folder
        PROJECT_ROOT = os.path.dirname(BASE_DIR)  # my-interview-app folder
        PARENT_DIR = os.path.dirname(PROJECT_ROOT)  # parent of my-interview-app
        
        categories_output_path = os.path.join(PARENT_DIR, "ResumeScanner_AI", "categories_output.csv")
        
        print(f"=== CATEGORIES DEBUG ===")
        print(f"Looking for categories at: {categories_output_path}")
        print(f"Categories file exists: {os.path.exists(categories_output_path)}")
        
        categories = []
        
        try:
            if os.path.exists(categories_output_path):
                with open(categories_output_path, 'r', newline='', encoding='utf-8') as csvfile:
                    reader = csv.DictReader(csvfile)
                    for row in reader:
                        if 'Category' in row and row['Category']:
                            categories.append(row['Category'])
                        elif 'category' in row and row['category']:
                            categories.append(row['category'])
                
                print(f"âœ“ Found {len(categories)} categories from resume: {categories}")
                return categories
            else:
                print("âŒ categories_output.csv not found, using default categories")
                return ["Python (Programming Language)", "Data Structures and Algorithms (DSA)", "Artificial Intelligence (AI) and Machine Learning (ML)"]
                
        except Exception as e:
            print(f"âŒ Error reading categories: {e}")
            return ["Python (Programming Language)", "Data Structures and Algorithms (DSA)"]
    
    def generate_questions(self, questions_per_category=3):
        """Generate personalized questions based on resume skills"""
        print("=== GENERATING QUESTIONS ===")
        chosen_categories = self.get_categories_from_resume()
        interview_questions = pd.DataFrame()

        for cat in chosen_categories:
            cat_questions = self.questions_df[self.questions_df['Category'] == cat]
            num_to_pick = min(questions_per_category, len(cat_questions))
            
            if num_to_pick > 0:
                selected = cat_questions.sample(num_to_pick, random_state=42)
                interview_questions = pd.concat([interview_questions, selected])
                print(f"âœ“ Selected {num_to_pick} questions for category: {cat}")

        # Shuffle questions and reset index
        if not interview_questions.empty:
            interview_questions = interview_questions.sample(frac=1, random_state=42).reset_index(drop=True)
            print(f"âœ“ Total questions selected: {len(interview_questions)}")
        else:
            print("âŒ No questions selected!")
            
        return interview_questions.to_dict('records')
    
    def score_answer(self, user_answer, ref_answers, question=None, category=None):
        """
        Score user answer against reference answers.
        
        Args:
            user_answer: The candidate's answer
            ref_answers: List of reference answers
            question: The question text (optional, for AI grading)
            category: Question category (optional, for AI grading)
        
        Returns:
            If AI grading available: (similarity_score, is_correct, ai_feedback)
            Otherwise: (similarity_score, is_correct)
        """
        try:
            print(f"=== SCORING ANSWER ===")
            print(f"User answer length: {len(user_answer)} characters")
            print(f"Reference answers: {len(ref_answers)}")
            
            # Calculate similarity score
            embeddings = self.model.encode(ref_answers + [user_answer])
            user_emb = embeddings[-1]
            ref_embs = embeddings[:-1]
            
            sim_scores = [util.cos_sim(user_emb, ref_emb)[0][0].item() for ref_emb in ref_embs]
            max_sim = max(sim_scores)
            
            print(f"âœ“ Similarity score: {max_sim:.3f}")
            
            # Determine correctness based on similarity threshold
            is_correct = max_sim > 0.5
            print(f"âœ“ Similarity grading: {max_sim:.3f} | Correct: {is_correct}")
            
            return max_sim, is_correct
            
        except Exception as e:
            print(f"âŒ Error scoring answer: {e}")
            import traceback
            traceback.print_exc()
            return 0.0, False

# Initialize the interview system
print("ğŸš€ INITIALIZING INTERVIEW SYSTEM...")
interview_system = InterviewSystem()
print("ğŸ‰ INTERVIEW SYSTEM READY!")